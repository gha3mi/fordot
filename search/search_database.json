var tipuesearch = {"pages":[{"title":" ForDot ","text":"ForDot ForDot : A Fortran library that overloads the dot_product function to enable efficient dot product with/without coarray. Usage use fordot a = dot_product ( u , v , coarray , option , nblock ) coarray is an optional logical variable. Set it to .true. and use the -DUSE_COARRAY flag to enable coarray. nblock is an optional integer variable. options is an optional character variable. Available options are 'm1' to 'm4' , and the default option is 'm2' . Note : Use the flag -DUSE_DO_CONCURRENT to enable do concurrent. This implementation of do concurrent is currently only supported by the Intel Compiler (ifx). Requirements A Fortran Compiler BLAS Library Fortran Package Manager (fpm) fpm Dependency If you want to use ForDot as a dependency in your own fpm project,\nyou can easily include it by adding the following line to your fpm.toml file: [dependencies] fordot = { git = \"https://github.com/gha3mi/fordot.git\" } Runing Tests Execute the following commands to run tests with specific compilers: fpm @<compiler>-test compiler: ifx, ifort, gfortran, nvfortran For coarray testing use: fpm @<compiler>-test-coarray compiler: ifx, ifort All compiler options are accessible in the fpm response file fpm.rsp . Benchmarks You can find benchmark results on ForBenchmark . API Documentation The most up-to-date API documentation for the master branch is available here .\nTo generate the API documentation for ForDot using ford run the following\ncommand: ford README.md Contributing Contributions to ForDot are welcome!\nIf you find any issues or would like to suggest improvements, please open an issue. Citation If you use ForDot in your work, please cite it using the following DOI: @software { ghasemi_2024_10594971 , author = { Ghasemi , Seyed Ali } , title = { gha3mi / fordot : v0 .1.0 } , month = jan , year = 2024 , publisher = { Zenodo } , version = { v0 .1.0 } , doi = { 10.5281 / zenodo .10594971 } , url = { https : // doi . org / 10.5281 / zenodo .10594971 } } Developer Info Seyed Ali Ghasemi","tags":"home","url":"index.html"},{"title":"dot_R0R1R1_rel – ForDot","text":"private pure function dot_R0R1R1_rel(u, v, option) result(a) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option Return Value real(kind=rk) Calls proc~~dot_r0r1r1_rel~~CallsGraph proc~dot_r0r1r1_rel dot_R0R1R1_rel interface~dot_opts dot_opts proc~dot_r0r1r1_rel->interface~dot_opts proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~md_2 md_2 proc~dot_r0r1r1_rel_opts->proc~md_2 proc~md_3 md_3 proc~dot_r0r1r1_rel_opts->proc~md_3 proc~md_4 md_4 proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dot_r0r1r1_rel~~CalledByGraph proc~dot_r0r1r1_rel dot_R0R1R1_rel interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function dot_R0R1R1_rel ( u , v , option ) result ( a ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: v (:) character ( * ), intent ( in ), optional :: option real ( rk ) :: a if ( present ( option )) then a = dot_opts ( u , v , option ) else a = dot_opts ( u , v , option = 'm2' ) end if end function dot_R0R1R1_rel","tags":"","url":"proc/dot_r0r1r1_rel.html"},{"title":"dot_R0R1R1_rel_block – ForDot","text":"private pure function dot_R0R1R1_rel_block(u, v, option, nblock) result(a) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk) Calls proc~~dot_r0r1r1_rel_block~~CallsGraph proc~dot_r0r1r1_rel_block dot_R0R1R1_rel_block proc~compute_block_ranges compute_block_ranges proc~dot_r0r1r1_rel_block->proc~compute_block_ranges reduce reduce proc~dot_r0r1r1_rel_block->reduce Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dot_r0r1r1_rel_block~~CalledByGraph proc~dot_r0r1r1_rel_block dot_R0R1R1_rel_block interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel_block program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function dot_R0R1R1_rel_block ( u , v , option , nblock ) result ( a ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: v (:) character ( * ), intent ( in ), optional :: option integer , intent ( in ) :: nblock real ( rk ) :: a integer :: im , se , ee integer :: block_size ( nblock ), start_elem ( nblock ), end_elem ( nblock ) call compute_block_ranges ( size ( u ), nblock , block_size , start_elem , end_elem ) a = 0.0_rk #if defined(USE_DO_CONCURRENT) do concurrent ( im = 1 : nblock ) reduce ( + : a ) se = start_elem ( im ) ee = end_elem ( im ) a = a + dot_product ( u ( se : ee ), v ( se : ee ), option ) end do #else do im = 1 , nblock se = start_elem ( im ) ee = end_elem ( im ) a = a + dot_product ( u ( se : ee ), v ( se : ee ), option ) end do #endif end function dot_R0R1R1_rel_block","tags":"","url":"proc/dot_r0r1r1_rel_block.html"},{"title":"dot_R0R1R1_rel_coarray – ForDot","text":"private impure function dot_R0R1R1_rel_coarray(u, v, option, coarray) result(a) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk) Calls proc~~dot_r0r1r1_rel_coarray~~CallsGraph proc~dot_r0r1r1_rel_coarray dot_R0R1R1_rel_coarray proc~compute_block_ranges compute_block_ranges proc~dot_r0r1r1_rel_coarray->proc~compute_block_ranges Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dot_r0r1r1_rel_coarray~~CalledByGraph proc~dot_r0r1r1_rel_coarray dot_R0R1R1_rel_coarray interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel_coarray program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code impure function dot_R0R1R1_rel_coarray ( u , v , option , coarray ) result ( a ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: v (:) character ( * ), intent ( in ), optional :: option real ( rk ) :: a logical , intent ( in ) :: coarray #if defined(USE_COARRAY) integer :: i , im , nimg , m , se , ee integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: a_block [:], u_block (:)[:], v_block (:)[:] im = this_image () nimg = num_images () m = size ( u ) call compute_block_ranges ( size ( u ), nimg , block_size , start_elem , end_elem ) allocate ( u_block ( block_size ( im ))[ * ], v_block ( block_size ( im ))[ * ], a_block [ * ]) se = start_elem ( im ) ee = end_elem ( im ) u_block (:)[ im ] = u ( se : ee ) v_block (:)[ im ] = v ( se : ee ) a_block [ im ] = dot_product ( u_block (:)[ im ], v_block (:)[ im ], option ) call co_sum ( a_block , result_image = 1 ) a = a_block [ 1 ] ! sync all ! if (im == 1) then !    a = 0.0_rk !    do i = 1, nimg !       a = a + a_block[i] !    end do ! end if #else a = dot_product ( u , v , option ) #endif end function dot_R0R1R1_rel_coarray","tags":"","url":"proc/dot_r0r1r1_rel_coarray.html"},{"title":"compute_block_ranges – ForDot","text":"private pure subroutine compute_block_ranges(d, nimg, block_size, start_elem, end_elem) Calculate block sizes and ranges.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: start_elem (nimg) integer, intent(out) :: end_elem (nimg) Called by proc~~compute_block_ranges~~CalledByGraph proc~compute_block_ranges compute_block_ranges proc~dot_r0r1r1_rel_block dot_R0R1R1_rel_block proc~dot_r0r1r1_rel_block->proc~compute_block_ranges proc~dot_r0r1r1_rel_coarray dot_R0R1R1_rel_coarray proc~dot_r0r1r1_rel_coarray->proc~compute_block_ranges interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel_block interface~dot_product->proc~dot_r0r1r1_rel_coarray program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure subroutine compute_block_ranges ( d , nimg , block_size , start_elem , end_elem ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), start_elem ( nimg ), end_elem ( nimg ) integer :: i , remainder block_size = d / nimg remainder = mod ( d , nimg ) block_size ( 1 : remainder ) = block_size ( 1 : remainder ) + 1 start_elem ( 1 ) = 1 do i = 2 , nimg start_elem ( i ) = start_elem ( i - 1 ) + block_size ( i - 1 ) end do end_elem ( 1 ) = block_size ( 1 ) end_elem ( 2 :) = start_elem ( 2 :) + block_size ( 2 :) - 1 ! Check if the block sizes are valid. if ( minval ( block_size ) <= 0 ) error stop 'ForDot: reduce the number of images of coarray.' end subroutine compute_block_ranges","tags":"","url":"proc/compute_block_ranges.html"},{"title":"dot_product – ForDot","text":"public interface dot_product Calls interface~~dot_product~~CallsGraph interface~dot_product dot_product proc~dot_r0r1r1_rel dot_R0R1R1_rel interface~dot_product->proc~dot_r0r1r1_rel proc~dot_r0r1r1_rel_block dot_R0R1R1_rel_block interface~dot_product->proc~dot_r0r1r1_rel_block proc~dot_r0r1r1_rel_coarray dot_R0R1R1_rel_coarray interface~dot_product->proc~dot_r0r1r1_rel_coarray interface~dot_opts dot_opts proc~dot_r0r1r1_rel->interface~dot_opts proc~compute_block_ranges compute_block_ranges proc~dot_r0r1r1_rel_block->proc~compute_block_ranges reduce reduce proc~dot_r0r1r1_rel_block->reduce proc~dot_r0r1r1_rel_coarray->proc~compute_block_ranges proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~md_2 md_2 proc~dot_r0r1r1_rel_opts->proc~md_2 proc~md_3 md_3 proc~dot_r0r1r1_rel_opts->proc~md_3 proc~md_4 md_4 proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dot_product~~CalledByGraph interface~dot_product dot_product program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function dot_R0R1R1_rel (u, v, option) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option Return Value real(kind=rk) private pure function dot_R0R1R1_rel_block (u, v, option, nblock) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk) private impure function dot_R0R1R1_rel_coarray (u, v, option, coarray) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk)","tags":"","url":"interface/dot_product.html"},{"title":"dot_R0R1R1_rel_opts – ForDot","text":"private pure function dot_R0R1R1_rel_opts(u, v, option) result(a) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v character(len=*), intent(in) :: option Return Value real(kind=rk) Calls proc~~dot_r0r1r1_rel_opts~~CallsGraph proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts proc~md_2 md_2 proc~dot_r0r1r1_rel_opts->proc~md_2 proc~md_3 md_3 proc~dot_r0r1r1_rel_opts->proc~md_3 proc~md_4 md_4 proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~dot_r0r1r1_rel_opts~~CalledByGraph proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts interface~dot_opts dot_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~dot_r0r1r1_rel dot_R0R1R1_rel proc~dot_r0r1r1_rel->interface~dot_opts interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function dot_R0R1R1_rel_opts ( u , v , option ) result ( a ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v character ( * ), intent ( in ) :: option real ( rk ) :: a select case ( option ) case ( 'm1' ) a = dot_product ( u , v ) case ( 'm2' ) a = md_2 ( u , v ) case ( 'm3' ) a = md_3 ( u , v ) case ( 'm4' ) a = md_4 ( u , v ) case default a = dot_product ( u , v ) end select end function dot_R0R1R1_rel_opts","tags":"","url":"proc/dot_r0r1r1_rel_opts.html"},{"title":"md_2 – ForDot","text":"private pure function md_2(u, v) result(a) Uses external_interfaces_dot proc~~md_2~~UsesGraph proc~md_2 md_2 module~external_interfaces_dot external_interfaces_dot proc~md_2->module~external_interfaces_dot kinds kinds module~external_interfaces_dot->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk) Calls proc~~md_2~~CallsGraph proc~md_2 md_2 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by proc~~md_2~~CalledByGraph proc~md_2 md_2 proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts proc~dot_r0r1r1_rel_opts->proc~md_2 interface~dot_opts dot_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~dot_r0r1r1_rel dot_R0R1R1_rel proc~dot_r0r1r1_rel->interface~dot_opts interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function md_2 ( u , v ) result ( a ) use external_interfaces_dot real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ) :: a a = dot ( size ( u ), u , 1 , v , 1 ) end function md_2","tags":"","url":"proc/md_2.html"},{"title":"md_3 – ForDot","text":"private pure function md_3(u, v) result(a) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk) Called by proc~~md_3~~CalledByGraph proc~md_3 md_3 proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts proc~dot_r0r1r1_rel_opts->proc~md_3 interface~dot_opts dot_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~dot_r0r1r1_rel dot_R0R1R1_rel proc~dot_r0r1r1_rel->interface~dot_opts interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function md_3 ( u , v ) result ( a ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ) :: a integer :: i a = 0.0_rk do i = 1 , size ( u ) a = a + u ( i ) * v ( i ) end do end function md_3","tags":"","url":"proc/md_3.html"},{"title":"md_4 – ForDot","text":"private pure function md_4(u, v) result(a) Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk) Called by proc~~md_4~~CalledByGraph proc~md_4 md_4 proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot_opts dot_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~dot_r0r1r1_rel dot_R0R1R1_rel proc~dot_r0r1r1_rel->interface~dot_opts interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code pure function md_4 ( u , v ) result ( a ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ) :: a a = sum ( u * v ) end function md_4","tags":"","url":"proc/md_4.html"},{"title":"dot_opts – ForDot","text":"public interface dot_opts Calls interface~~dot_opts~~CallsGraph interface~dot_opts dot_opts proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~md_2 md_2 proc~dot_r0r1r1_rel_opts->proc~md_2 proc~md_3 md_3 proc~dot_r0r1r1_rel_opts->proc~md_3 proc~md_4 md_4 proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Called by interface~~dot_opts~~CalledByGraph interface~dot_opts dot_opts proc~dot_r0r1r1_rel dot_R0R1R1_rel proc~dot_r0r1r1_rel->interface~dot_opts interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Module Procedures private pure function dot_R0R1R1_rel_opts (u, v, option) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v character(len=*), intent(in) :: option Return Value real(kind=rk)","tags":"","url":"interface/dot_opts.html"},{"title":"dot – ForDot","text":"public interface dot Called by interface~~dot~~CalledByGraph interface~dot dot proc~md_2 md_2 proc~md_2->interface~dot proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts proc~dot_r0r1r1_rel_opts->proc~md_2 interface~dot_opts dot_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~dot_r0r1r1_rel dot_R0R1R1_rel proc~dot_r0r1r1_rel->interface~dot_opts interface~dot_product dot_product interface~dot_product->proc~dot_r0r1r1_rel program~test_dot1 test_dot1 program~test_dot1->interface~dot_product program~test_dot2 test_dot2 program~test_dot2->interface~dot_product Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Functions public pure function ddot(f_n, f_dx, f_incx, f_dy, f_incy) result(f_a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_dx (f_n) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_dy (f_n) integer, intent(in) :: f_incy Return Value real(kind=rk) public pure function ddot(f_n, f_dx, f_incx, f_dy, f_incy) result(f_a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_dx (f_n) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_dy (f_n) integer, intent(in) :: f_incy Return Value real(kind=rk) public pure function sdot(f_n, f_dx, f_incx, f_dy, f_incy) result(f_a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_dx (f_n) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_dy (f_n) integer, intent(in) :: f_incy Return Value real(kind=rk)","tags":"","url":"interface/dot.html"},{"title":"fordot – ForDot","text":"Uses fordot_opts kinds module~~fordot~~UsesGraph module~fordot fordot kinds kinds module~fordot->kinds module~fordot_opts fordot_opts module~fordot->module~fordot_opts module~fordot_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~fordot~~UsedByGraph module~fordot fordot program~test_dot1 test_dot1 program~test_dot1->module~fordot program~test_dot2 test_dot2 program~test_dot2->module~fordot Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface dot_product private pure function dot_R0R1R1_rel (u, v, option) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option Return Value real(kind=rk) private pure function dot_R0R1R1_rel_block (u, v, option, nblock) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk) private impure function dot_R0R1R1_rel_coarray (u, v, option, coarray) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk) Functions private pure function dot_R0R1R1_rel (u, v, option) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option Return Value real(kind=rk) private pure function dot_R0R1R1_rel_block (u, v, option, nblock) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option integer, intent(in) :: nblock Return Value real(kind=rk) private impure function dot_R0R1R1_rel_coarray (u, v, option, coarray) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), contiguous :: u (:) real(kind=rk), intent(in), contiguous :: v (:) character(len=*), intent(in), optional :: option logical, intent(in) :: coarray Return Value real(kind=rk) Subroutines private pure subroutine compute_block_ranges (d, nimg, block_size, start_elem, end_elem) Calculate block sizes and ranges.\nauthor: Seyed Ali Ghasemi Arguments Type Intent Optional Attributes Name integer, intent(in) :: d integer, intent(in) :: nimg integer, intent(out) :: block_size (nimg) integer, intent(out) :: start_elem (nimg) integer, intent(out) :: end_elem (nimg)","tags":"","url":"module/fordot.html"},{"title":"fordot_opts – ForDot","text":"Uses kinds module~~fordot_opts~~UsesGraph module~fordot_opts fordot_opts kinds kinds module~fordot_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~fordot_opts~~UsedByGraph module~fordot_opts fordot_opts module~fordot fordot module~fordot->module~fordot_opts program~test_dot1 test_dot1 program~test_dot1->module~fordot program~test_dot2 test_dot2 program~test_dot2->module~fordot Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface dot_opts private pure function dot_R0R1R1_rel_opts (u, v, option) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v character(len=*), intent(in) :: option Return Value real(kind=rk) Functions private pure function dot_R0R1R1_rel_opts (u, v, option) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v character(len=*), intent(in) :: option Return Value real(kind=rk) private pure function md_2 (u, v) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk) private pure function md_3 (u, v) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk) private pure function md_4 (u, v) result(a) Author Seyed Ali Ghasemi License BSD 3-Clause Arguments Type Intent Optional Attributes Name real(kind=rk), intent(in), dimension(:), contiguous :: u real(kind=rk), intent(in), dimension(:), contiguous :: v Return Value real(kind=rk)","tags":"","url":"module/fordot_opts.html"},{"title":"external_interfaces_dot – ForDot","text":"Uses kinds module~~external_interfaces_dot~~UsesGraph module~external_interfaces_dot external_interfaces_dot kinds kinds module~external_interfaces_dot->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Used by module~~external_interfaces_dot~~UsedByGraph module~external_interfaces_dot external_interfaces_dot proc~md_2 md_2 proc~md_2->module~external_interfaces_dot Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Interfaces public        interface dot public pure function ddot(f_n, f_dx, f_incx, f_dy, f_incy) result(f_a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_dx (f_n) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_dy (f_n) integer, intent(in) :: f_incy Return Value real(kind=rk) public pure function ddot(f_n, f_dx, f_incx, f_dy, f_incy) result(f_a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_dx (f_n) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_dy (f_n) integer, intent(in) :: f_incy Return Value real(kind=rk) public pure function sdot(f_n, f_dx, f_incx, f_dy, f_incy) result(f_a) Arguments Type Intent Optional Attributes Name integer, intent(in) :: f_n real(kind=rk), intent(in) :: f_dx (f_n) integer, intent(in) :: f_incx real(kind=rk), intent(in) :: f_dy (f_n) integer, intent(in) :: f_incy Return Value real(kind=rk)","tags":"","url":"module/external_interfaces_dot.html"},{"title":"test_dot2 – ForDot","text":"Uses forunittest kinds fordot program~~test_dot2~~UsesGraph program~test_dot2 test_dot2 forunittest forunittest program~test_dot2->forunittest kinds kinds program~test_dot2->kinds module~fordot fordot program~test_dot2->module~fordot module~fordot->kinds module~fordot_opts fordot_opts module~fordot->module~fordot_opts module~fordot_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_dot2~~CallsGraph program~test_dot2 test_dot2 check check program~test_dot2->check interface~dot_product dot_product program~test_dot2->interface~dot_product proc~dot_r0r1r1_rel dot_R0R1R1_rel interface~dot_product->proc~dot_r0r1r1_rel proc~dot_r0r1r1_rel_block dot_R0R1R1_rel_block interface~dot_product->proc~dot_r0r1r1_rel_block proc~dot_r0r1r1_rel_coarray dot_R0R1R1_rel_coarray interface~dot_product->proc~dot_r0r1r1_rel_coarray interface~dot_opts dot_opts proc~dot_r0r1r1_rel->interface~dot_opts proc~compute_block_ranges compute_block_ranges proc~dot_r0r1r1_rel_block->proc~compute_block_ranges reduce reduce proc~dot_r0r1r1_rel_block->reduce proc~dot_r0r1r1_rel_coarray->proc~compute_block_ranges proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~md_2 md_2 proc~dot_r0r1r1_rel_opts->proc~md_2 proc~md_3 md_3 proc~dot_r0r1r1_rel_opts->proc~md_3 proc~md_4 md_4 proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: a real(kind=rk) :: a_ref integer :: im integer :: m real(kind=rk), allocatable :: u (:) type(unit_test) :: ut real(kind=rk), allocatable :: v (:) Source Code program test_dot2 use kinds use fordot , only : fdot_product => dot_product ! rename dot_product to fdot_product to avoid overloading use forunittest , only : unit_test implicit none real ( rk ), allocatable :: u (:), v (:) real ( rk ) :: a_ref , a integer :: m , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! a = u(m).v(n) m = 500 allocate ( u ( m ), v ( m )) call random_number ( u ) call random_number ( v ) u = u * 10 0.0_rk v = v * 10 0.0_rk a_ref = dot_product ( u , v ) a = fdot_product ( u , v , coarray = . true ., option = 'm1' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.1' ) a = fdot_product ( u , v , coarray = . true ., option = 'm2' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.2' ) a = fdot_product ( u , v , coarray = . true ., option = 'm3' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.3' ) a = fdot_product ( u , v , coarray = . true ., option = 'm4' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.4' ) end program test_dot2","tags":"","url":"program/test_dot2.html"},{"title":"test_dot1 – ForDot","text":"Uses forunittest kinds fordot program~~test_dot1~~UsesGraph program~test_dot1 test_dot1 forunittest forunittest program~test_dot1->forunittest kinds kinds program~test_dot1->kinds module~fordot fordot program~test_dot1->module~fordot module~fordot->kinds module~fordot_opts fordot_opts module~fordot->module~fordot_opts module~fordot_opts->kinds Help Graph Key Nodes of different colours represent the following: Graph Key Module Module Submodule Submodule Subroutine Subroutine Function Function Program Program This Page's Entity This Page's Entity Solid arrows point from a submodule to the (sub)module which it is\ndescended from. Dashed arrows point from a module or program unit to \nmodules which it uses. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Calls program~~test_dot1~~CallsGraph program~test_dot1 test_dot1 check check program~test_dot1->check interface~dot_product dot_product program~test_dot1->interface~dot_product proc~dot_r0r1r1_rel dot_R0R1R1_rel interface~dot_product->proc~dot_r0r1r1_rel proc~dot_r0r1r1_rel_block dot_R0R1R1_rel_block interface~dot_product->proc~dot_r0r1r1_rel_block proc~dot_r0r1r1_rel_coarray dot_R0R1R1_rel_coarray interface~dot_product->proc~dot_r0r1r1_rel_coarray interface~dot_opts dot_opts proc~dot_r0r1r1_rel->interface~dot_opts proc~compute_block_ranges compute_block_ranges proc~dot_r0r1r1_rel_block->proc~compute_block_ranges reduce reduce proc~dot_r0r1r1_rel_block->reduce proc~dot_r0r1r1_rel_coarray->proc~compute_block_ranges proc~dot_r0r1r1_rel_opts dot_R0R1R1_rel_opts interface~dot_opts->proc~dot_r0r1r1_rel_opts proc~md_2 md_2 proc~dot_r0r1r1_rel_opts->proc~md_2 proc~md_3 md_3 proc~dot_r0r1r1_rel_opts->proc~md_3 proc~md_4 md_4 proc~dot_r0r1r1_rel_opts->proc~md_4 interface~dot dot proc~md_2->interface~dot Help Graph Key Nodes of different colours represent the following: Graph Key Subroutine Subroutine Function Function Interface Interface Type Bound Procedure Type Bound Procedure Unknown Procedure Type Unknown Procedure Type Program Program This Page's Entity This Page's Entity Solid arrows point from a procedure to one which it calls. Dashed \narrows point from an interface to procedures which implement that interface.\nThis could include the module procedures in a generic interface or the\nimplementation in a submodule of an interface in a parent module. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Variables Type Attributes Name Initial real(kind=rk) :: a real(kind=rk) :: a_ref integer :: m real(kind=rk), allocatable :: u (:) type(unit_test) :: ut real(kind=rk), allocatable :: v (:) Source Code program test_dot1 use kinds use fordot , only : fdot_product => dot_product ! rename dot_product to fdot_product to avoid overloading use forunittest , only : unit_test implicit none real ( rk ), allocatable :: u (:), v (:) real ( rk ) :: a_ref , a integer :: m type ( unit_test ) :: ut ! a = u(m).v(m) m = 300 allocate ( u ( m ), v ( m )) call random_number ( u ) call random_number ( v ) u = u * 10 0.0_rk v = v * 10 0.0_rk a_ref = dot_product ( u , v ) a = fdot_product ( u , v ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.1' ) a = fdot_product ( u , v , option = 'm1' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.2' ) a = fdot_product ( u , v , option = 'm2' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.3' ) a = fdot_product ( u , v , option = 'm3' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.4' ) a = fdot_product ( u , v , option = 'm4' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.5' ) a = fdot_product ( u , v , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.6' ) a = fdot_product ( u , v , option = 'm1b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.7' ) a = fdot_product ( u , v , option = 'm2b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.8' ) a = fdot_product ( u , v , option = 'm3b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.9' ) a = fdot_product ( u , v , option = 'm4b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.10' ) end program test_dot1","tags":"","url":"program/test_dot1.html"},{"title":"test2.f90 – ForDot","text":"This file depends on sourcefile~~test2.f90~~EfferentGraph sourcefile~test2.f90 test2.f90 sourcefile~fordot.f90 fordot.f90 sourcefile~test2.f90->sourcefile~fordot.f90 sourcefile~fordot_options.f90 fordot_options.f90 sourcefile~fordot.f90->sourcefile~fordot_options.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~fordot_options.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_dot2 use kinds use fordot , only : fdot_product => dot_product ! rename dot_product to fdot_product to avoid overloading use forunittest , only : unit_test implicit none real ( rk ), allocatable :: u (:), v (:) real ( rk ) :: a_ref , a integer :: m , im type ( unit_test ) :: ut #if defined(USE_COARRAY) im = this_image () #else im = 1 #endif ! a = u(m).v(n) m = 500 allocate ( u ( m ), v ( m )) call random_number ( u ) call random_number ( v ) u = u * 10 0.0_rk v = v * 10 0.0_rk a_ref = dot_product ( u , v ) a = fdot_product ( u , v , coarray = . true ., option = 'm1' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.1' ) a = fdot_product ( u , v , coarray = . true ., option = 'm2' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.2' ) a = fdot_product ( u , v , coarray = . true ., option = 'm3' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.3' ) a = fdot_product ( u , v , coarray = . true ., option = 'm4' ) if ( im == 1 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot2.4' ) end program test_dot2","tags":"","url":"sourcefile/test2.f90.html"},{"title":"test1.f90 – ForDot","text":"This file depends on sourcefile~~test1.f90~~EfferentGraph sourcefile~test1.f90 test1.f90 sourcefile~fordot.f90 fordot.f90 sourcefile~test1.f90->sourcefile~fordot.f90 sourcefile~fordot_options.f90 fordot_options.f90 sourcefile~fordot.f90->sourcefile~fordot_options.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~fordot_options.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code program test_dot1 use kinds use fordot , only : fdot_product => dot_product ! rename dot_product to fdot_product to avoid overloading use forunittest , only : unit_test implicit none real ( rk ), allocatable :: u (:), v (:) real ( rk ) :: a_ref , a integer :: m type ( unit_test ) :: ut ! a = u(m).v(m) m = 300 allocate ( u ( m ), v ( m )) call random_number ( u ) call random_number ( v ) u = u * 10 0.0_rk v = v * 10 0.0_rk a_ref = dot_product ( u , v ) a = fdot_product ( u , v ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.1' ) a = fdot_product ( u , v , option = 'm1' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.2' ) a = fdot_product ( u , v , option = 'm2' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.3' ) a = fdot_product ( u , v , option = 'm3' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.4' ) a = fdot_product ( u , v , option = 'm4' ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.5' ) a = fdot_product ( u , v , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.6' ) a = fdot_product ( u , v , option = 'm1b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.7' ) a = fdot_product ( u , v , option = 'm2b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.8' ) a = fdot_product ( u , v , option = 'm3b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.9' ) a = fdot_product ( u , v , option = 'm4b' , nblock = 16 ) call ut % check ( a , a_ref , tol = 1e-5_rk , msg = 'test_dot1.10' ) end program test_dot1","tags":"","url":"sourcefile/test1.f90.html"},{"title":"fordot.f90 – ForDot","text":"This file depends on sourcefile~~fordot.f90~~EfferentGraph sourcefile~fordot.f90 fordot.f90 sourcefile~fordot_options.f90 fordot_options.f90 sourcefile~fordot.f90->sourcefile~fordot_options.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~fordot_options.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~fordot.f90~~AfferentGraph sourcefile~fordot.f90 fordot.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~fordot.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~fordot.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module fordot use kinds use fordot_opts , only : dot_opts implicit none private public :: dot_product interface dot_product procedure :: dot_R0R1R1_rel procedure :: dot_R0R1R1_rel_block procedure :: dot_R0R1R1_rel_coarray end interface contains !> author: Seyed Ali Ghasemi pure function dot_R0R1R1_rel ( u , v , option ) result ( a ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: v (:) character ( * ), intent ( in ), optional :: option real ( rk ) :: a if ( present ( option )) then a = dot_opts ( u , v , option ) else a = dot_opts ( u , v , option = 'm2' ) end if end function dot_R0R1R1_rel !> author: Seyed Ali Ghasemi pure function dot_R0R1R1_rel_block ( u , v , option , nblock ) result ( a ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: v (:) character ( * ), intent ( in ), optional :: option integer , intent ( in ) :: nblock real ( rk ) :: a integer :: im , se , ee integer :: block_size ( nblock ), start_elem ( nblock ), end_elem ( nblock ) call compute_block_ranges ( size ( u ), nblock , block_size , start_elem , end_elem ) a = 0.0_rk #if defined(USE_DO_CONCURRENT) do concurrent ( im = 1 : nblock ) reduce ( + : a ) se = start_elem ( im ) ee = end_elem ( im ) a = a + dot_product ( u ( se : ee ), v ( se : ee ), option ) end do #else do im = 1 , nblock se = start_elem ( im ) ee = end_elem ( im ) a = a + dot_product ( u ( se : ee ), v ( se : ee ), option ) end do #endif end function dot_R0R1R1_rel_block !> author: Seyed Ali Ghasemi impure function dot_R0R1R1_rel_coarray ( u , v , option , coarray ) result ( a ) real ( rk ), intent ( in ), contiguous :: u (:) real ( rk ), intent ( in ), contiguous :: v (:) character ( * ), intent ( in ), optional :: option real ( rk ) :: a logical , intent ( in ) :: coarray #if defined(USE_COARRAY) integer :: i , im , nimg , m , se , ee integer :: block_size ( num_images ()), start_elem ( num_images ()), end_elem ( num_images ()) real ( rk ), allocatable :: a_block [:], u_block (:)[:], v_block (:)[:] im = this_image () nimg = num_images () m = size ( u ) call compute_block_ranges ( size ( u ), nimg , block_size , start_elem , end_elem ) allocate ( u_block ( block_size ( im ))[ * ], v_block ( block_size ( im ))[ * ], a_block [ * ]) se = start_elem ( im ) ee = end_elem ( im ) u_block (:)[ im ] = u ( se : ee ) v_block (:)[ im ] = v ( se : ee ) a_block [ im ] = dot_product ( u_block (:)[ im ], v_block (:)[ im ], option ) call co_sum ( a_block , result_image = 1 ) a = a_block [ 1 ] ! sync all ! if (im == 1) then !    a = 0.0_rk !    do i = 1, nimg !       a = a + a_block[i] !    end do ! end if #else a = dot_product ( u , v , option ) #endif end function dot_R0R1R1_rel_coarray !> Calculate block sizes and ranges. !> author: Seyed Ali Ghasemi pure subroutine compute_block_ranges ( d , nimg , block_size , start_elem , end_elem ) integer , intent ( in ) :: d , nimg integer , intent ( out ) :: block_size ( nimg ), start_elem ( nimg ), end_elem ( nimg ) integer :: i , remainder block_size = d / nimg remainder = mod ( d , nimg ) block_size ( 1 : remainder ) = block_size ( 1 : remainder ) + 1 start_elem ( 1 ) = 1 do i = 2 , nimg start_elem ( i ) = start_elem ( i - 1 ) + block_size ( i - 1 ) end do end_elem ( 1 ) = block_size ( 1 ) end_elem ( 2 :) = start_elem ( 2 :) + block_size ( 2 :) - 1 ! Check if the block sizes are valid. if ( minval ( block_size ) <= 0 ) error stop 'ForDot: reduce the number of images of coarray.' end subroutine compute_block_ranges end module fordot","tags":"","url":"sourcefile/fordot.f90.html"},{"title":"fordot_options.f90 – ForDot","text":"This file depends on sourcefile~~fordot_options.f90~~EfferentGraph sourcefile~fordot_options.f90 fordot_options.f90 sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~fordot_options.f90->sourcefile~external_interfaces.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Files dependent on this one sourcefile~~fordot_options.f90~~AfferentGraph sourcefile~fordot_options.f90 fordot_options.f90 sourcefile~fordot.f90 fordot.f90 sourcefile~fordot.f90->sourcefile~fordot_options.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~fordot.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~fordot.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module fordot_opts use kinds implicit none private public :: dot_opts interface dot_opts procedure :: dot_R0R1R1_rel_opts end interface contains !> author: Seyed Ali Ghasemi pure function dot_R0R1R1_rel_opts ( u , v , option ) result ( a ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v character ( * ), intent ( in ) :: option real ( rk ) :: a select case ( option ) case ( 'm1' ) a = dot_product ( u , v ) case ( 'm2' ) a = md_2 ( u , v ) case ( 'm3' ) a = md_3 ( u , v ) case ( 'm4' ) a = md_4 ( u , v ) case default a = dot_product ( u , v ) end select end function dot_R0R1R1_rel_opts !> author: Seyed Ali Ghasemi pure function md_2 ( u , v ) result ( a ) use external_interfaces_dot real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ) :: a a = dot ( size ( u ), u , 1 , v , 1 ) end function md_2 !> author: Seyed Ali Ghasemi pure function md_3 ( u , v ) result ( a ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ) :: a integer :: i a = 0.0_rk do i = 1 , size ( u ) a = a + u ( i ) * v ( i ) end do end function md_3 !> author: Seyed Ali Ghasemi pure function md_4 ( u , v ) result ( a ) real ( rk ), dimension (:), intent ( in ), contiguous :: u , v real ( rk ) :: a a = sum ( u * v ) end function md_4 end module fordot_opts","tags":"","url":"sourcefile/fordot_options.f90.html"},{"title":"external_interfaces.f90 – ForDot","text":"Files dependent on this one sourcefile~~external_interfaces.f90~~AfferentGraph sourcefile~external_interfaces.f90 external_interfaces.f90 sourcefile~fordot_options.f90 fordot_options.f90 sourcefile~fordot_options.f90->sourcefile~external_interfaces.f90 sourcefile~fordot.f90 fordot.f90 sourcefile~fordot.f90->sourcefile~fordot_options.f90 sourcefile~test1.f90 test1.f90 sourcefile~test1.f90->sourcefile~fordot.f90 sourcefile~test2.f90 test2.f90 sourcefile~test2.f90->sourcefile~fordot.f90 Help Graph Key Nodes of different colours represent the following: Graph Key Source File Source File This Page's Entity This Page's Entity Solid arrows point from a file to a file which it depends on. A file\nis dependent upon another if the latter must be compiled before the former\ncan be. Where possible, edges connecting nodes are\ngiven different colours to make them easier to distinguish in\nlarge graphs. Source Code module external_interfaces_dot use kinds implicit none interface dot #if defined(REAL64) pure function ddot ( f_n , f_dx , f_incx , f_dy , f_incy ) result ( f_a ) import rk integer , intent ( in ) :: f_incx , f_incy , f_n real ( rk ), intent ( in ) :: f_dx ( f_n ), f_dy ( f_n ) real ( rk ) :: f_a end function ddot #elif defined(REAL32) pure function sdot ( f_n , f_dx , f_incx , f_dy , f_incy ) result ( f_a ) import rk integer , intent ( in ) :: f_incx , f_incy , f_n real ( rk ), intent ( in ) :: f_dx ( f_n ), f_dy ( f_n ) real ( rk ) :: f_a end function sdot #else pure function ddot ( f_n , f_dx , f_incx , f_dy , f_incy ) result ( f_a ) import rk integer , intent ( in ) :: f_incx , f_incy , f_n real ( rk ), intent ( in ) :: f_dx ( f_n ), f_dy ( f_n ) real ( rk ) :: f_a end function ddot #endif end interface end module external_interfaces_dot","tags":"","url":"sourcefile/external_interfaces.f90.html"}]}